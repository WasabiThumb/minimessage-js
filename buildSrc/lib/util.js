/*
 * Common but otherwise unrelated utilities for buildSrc
 */

const fs = require("node:fs/promises");
const stream = require("node:stream");

/**
 * Memoizes a function with no parameters.
 *
 * @template T
 * @param fn { () => T }
 * @return { () => T }
 */
function memoize(fn) {
    let value = null;
    let computed = false;
    return (() => {
        if (computed) return value;
        value = fn();
        computed = true;
        return value;
    });
}

/**
 * Helper function, in absence of TypeScript, to read typed fields from the result of a JSON endpoint.
 *
 * @param object {any} Object to get value of
 * @param key {string} Key to index into object with
 * @param type {"array" | "object" | "string"} Type that ``object[key]`` should have
 * @return {any}
 */
function typedGet(object, key, type) {
    if (!(key in object)) throw new Error(`Bad data from API: \"${key}\" not present`);
    const value = object[key];
    let match = (type === "array") ? Array.isArray(value) : (typeof value === type);
    if (!match) throw new Error(`Bad data from API: \"${key}\" is not of type ${type}`);
    return value;
}

/**
 * Similar to indexOf, but ``needle`` is guaranteed to be 1 character long.
 * @param haystack {string}
 * @param needle {string}
 * @return {number}
 */
function indexOfChar(haystack, needle) {
    const code = needle.codePointAt(0);
    for (let i=0; i < haystack.length; i++) {
        if (code === haystack.codePointAt(i)) return i;
    }
    return -1;
}

/**
 * @param url {string} URL to fetch
 * @param headers { { [key: string]: string } | undefined } Request headers
 * @return {Promise<Readable>}
 */
function fetchStream(url, headers) {
    // noinspection JSValidateTypes
    return fetch(url, {
        method: "GET",
        headers
    }).then((r) => {
        const { body } = r;
        if (body === null) throw new Error(`Bad data from API: Null body`);
        return stream.Readable.fromWeb(body);
    });
}

/**
 * Writes key-values to a TS source file
 * @param out { string }
 * @param properties { { [key: string]: any } }
 * @param comments { { [key: string]: string | undefined } | undefined }
 * @return {Promise<void>}
 */
async function writePropertiesFile(out, properties, comments) {
    const hasComments = (typeof comments === "object");
    const fh = await fs.open(out, "w");
    try {
        const HEADER = "/*\n * THIS FILE IS AUTOMATICALLY GENERATED\n * DO NOT EDIT MANUALLY\n * SEE buildSrc/lib/util.js\n*/\n";
        await fh.writeFile(HEADER, "utf-8");

        let value, valueType, comment;
        for (const key of Object.keys(properties)) {
            value = properties[key];
            valueType = typeof value;

            comment = hasComments && comments[key];
            await fh.writeFile((!!comment) ? `\n/** ${comment} */\n` : `\n\n`, "utf-8");

            await fh.writeFile(`export const ${key}: ${valueType} = `, "utf-8");

            switch (valueType) {
                case "number":
                    await fh.writeFile(value.toString(), "utf-8");
                    break;
                case "string":
                    await fh.writeFile("\"" + value.replace(/"/g, "\\\"") + "\"", "utf-8");
                    break;
                default:
                    throw new Error("No serializer implemented for property type: " + valueType);
            }

            await fh.writeFile(`;\n`, "utf-8");
        }
    } finally {
        await fh.close();
    }
}

module.exports = { memoize, typedGet, indexOfChar, writePropertiesFile, fetchStream };

